\documentclass[12pt, a4paper]{article}
\usepackage[pdftex,dvipsnames]{color}
\usepackage{graphicx}
\usepackage{times}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{url}
\usepackage{amsmath}
\usepackage{amsfonts}
\newcommand{\eps}{\varepsilon}
\newcommand{\abso}[1]{\;\mid#1\mid\;}
\renewcommand{\=}{\,=\,}
\newcommand{\+}{\,+\,}
% ----------------------------------------------------------------
\newcommand{\remark}[1]{\par\noindent{\color[named]{ProcessBlue}#1}\par}
\newcommand{\mcc}[2]{\multicolumn{#1}{c}{#2}}
\newcommand{\mcp}[2]{\multicolumn{#1}{c|}{#2}}
\newcommand{\nm}[1]{\textsf{\small #1}}
\newcommand{\nnm}[1]{\textsf{\small\textit{#1}}}
\newcommand{\nmm}[1]{\nnm{#1}}
\newcommand{\sfn}[1]{\textbf{\texttt{#1}}}

% no labels in list of references:
\makeatletter
\renewcommand\@biblabel{}
\makeatother

\hyphenation{Snij-ders Duijn DataSpecification dataspecification dependentvariable ModelSpecification}

% centered section headings with a period after the number;
% sans serif fonts for section and subsection headings
\renewcommand{\thesection}{\arabic{section}.}
\renewcommand{\thesubsection}{\thesection\arabic{subsection}}
\makeatletter
 \renewcommand{\section}{\@startsection{section}{1}
                {0pt}{\baselineskip}{0.5\baselineskip}
                {\centering\sffamily} }
 \renewcommand{\subsection}{\@startsection{subsection}{2}
                {0pt}{0.7\baselineskip}{0.3\baselineskip}
                {\sffamily} }
\makeatother


\renewcommand{\baselinestretch}{1.0} %% For line spacing.
\setlength{\parindent}{0pt}
\setlength{\parskip}{1ex plus1ex}
\raggedright
\begin{document}

\title{Notes for Developers of RSiena}
\author{Ruth Ripley}
\date{}
\maketitle

\centerline{\emph{\today}}
\bigskip

The introduction to the RSiena manual describes the basics of how to run the
program, either `standalone' or within R. The help files in R describe how to
use the R commands. Here I give some notes for developers.
\section{Coding standards}
I describe the main details of our current practice:
\subsection{General}
\begin{enumerate}
\item Use lots of spaces: particularly around operators and after commas.
\item Do not use underscores: use variable names made up of several (possibly
  abbreviated) words with all but the first capitalised.
\item Use braces even when not strictly necessary in \sfn{if} and \sfn{for}
  statements and similar. (Not universal yet, but I am adding them...)
\item Align braces under each other (so put the first one on a new line). (I
  break this rule for \sfn{switch} statements in R as emacs does not do the
  alignment sensibly!)
\item Set tabs at intervals of 4 columns
\item Indent by 4
\item Align comments in the body of the code with the surrounding code.
\item Do not use lines longer than 80 characters.
\item New source files need their \sfn{eol-style} set to \sfn{native} when they
  are added to the repository. On Windows, right-click and select
  Tortoise-SVN/properties then add \sfn{eol-style:native}.  (One current
  exception here: the file \sfn{sienascript} needs to have always unix line
  endings. Otherwise a tarball built on Windows will not produce a usable
  \sfn{sienascript} for Mac or Linux. There may be others in the future.)
\item Copy a file header from an existing source file.
\end{enumerate}
\subsection{R}
\begin{enumerate}
\item Use \verb|<-| rather than \verb|=| for assignment.
\item Use \sfn{TRUE} and \sfn{FALSE} not \sfn{T} and \sfn{F}.
\item Avoid unnecessary \sfn{for} loops. They are acceptable where a complicated
  \sfn{apply} statement would be necessary,  but not where a simple vectorised
    command could be used.
  \item \sfn{R} functions need a documentation comment preceding the function
    declaration. If they have internal functions a call to \sfn{getInternals} is
    required also.
  \item \sfn{R} functions which are to be visible to the user need to be added
    to the \sfn{NAMESPACE} file, and have a help page for them : see the Writing
    R Extensions manual for the details of the format.
  \item Check that \sfn{R CMD check} works with no warnings apart from line
    endings (these are set to follow the platform, and will be OK when checked
    out on a Linux box).
  \item If writing methods, add them to the \sfn{NAMESPACE} file. Ensure that
    you get no warnings from them.
  \item \sfn{print} methods should invisibly return their argument.
  \item \sfn{summary} methods for class \sfn{objclass} should return an object
    of class \sfn{summary.objclass} which is printed by a
    \sfn{print.summary.objclass} method.
\item Avoid using the names of \sfn{R} functions as variable names. It is
  permitted but may lead to confusion.
\end{enumerate}
\section{Recreating the package}
\begin{enumerate}
\item If using Windows, download and install the latest
\textsf{Rtools.exe} from
  \url{http://www.murdoch-sutherland.com/Rtools/}.  Beware: if you later install
  other programs containing utilities such as tar (delphi is one offender), you
  may need to uninstall and reinstall Rtools, as you need Rtools at the start of
  your path. (Or edit the path!).
\item If using a Mac, you will need the Xcode tools installed.
\item Obtain the current source.
\item In a command prompt window, navigate to the directory above the siena
  tree. Here I assume it is called \sfn{RSiena}. (You may have minor
  difficulties if it is not!)
\item Type\\
\verb|R CMD build RSiena|
\item You will probably need to either add R to your path, or use
  `path-to-R.exe' in the command above.
\item When this one is OK, type\\
\verb|R CMD INSTALL RSiena_1.0.n.tar.gz|\\
(where \verb|n| is adjusted to match the file you have just created.)
\item You now should have a new version of the package ready for use.
\item Alternatively, instead of the build and INSTALL, just type
\verb|R CMD INSTALL RSiena|\\
This will just compile the C that has changed and then do the rest.
Quicker if you are debugging changes. Note that the \sfn{make} file is not very
clever: if you are altering the C and your changes are not appearing, delete the
.o's or .dll to force it, or do a build
to clear out all the .o's and the dll.
\item On linux or Mac, the same commands should work, but you don't need the
  Rtools. I have occasionally had problems with installing from a tarball or
  from source, when I have no permission to write in the standard libraries, but
  can't remember which one worked: one always did. The most likely to work is to
  use, within R, \sfn{install.packages("tarball name", repos=NULL)}.
\item If you find a Mac keeps recompiling all the C, even when you have not
  changed anything, remove the word ``clean'' from the line beginning with the
  word ``all'' in the file \verb|RSiena/src/Makevars|. But try to remember not
  to commit this version!
\item Checking the package. Either run \verb|R CMD check RSiena|, or do a build
  and run\verb|R CMD check RSiena_1.0.n.tar.gz|. This will create a directory
  called \verb|RSiena.Rcheck|, and produce some diagnostics to the screen. You
  should have no warnings at all from the tar ball version, maybe some to do
  with presence of object files with the other version. Once the warnings have
  gone away, do a final check on the pdf version of the help pages which will be
  in the directory RSiena.RCheck. Check any pages you have changed for lines
  that are too long: the usage section, I think, does not wrap automatically.
\end{enumerate}
\paragraph{Alternative methods for small changes}
Now we have a \textsf{name space} for the package, small changes are not really
possible.
\begin{enumerate}
\item If you make a change to an R source file, you can sometimes override the
  package simply by sourcing the R file into the R session. If you have changed
  the function \textsf{simstats0c}, you will need to recreate the model object
  too. But if the functions you have changed call hidden functions in the
  package, then this will fail, unless you source any others necessary\ldots it
  may be easier to recreate the package.
\item You can make a small change to a hidden file by using
\verb|fixInNamespace('function name', 'RSiena')|.
\item Useful to insert a call to \sfn{browser}, as you won't mind it
  disappearing when you exit from R.
\end{enumerate}
\section{Parallel runs}
\begin{enumerate}
\item In Siena3324xx source file \textsf{rangen.pas}, edit the lines at the
  bottom so that \textsf{version = 5} and \textsf{version2 = 6}.
\item Build siena01, siena07
\item Set the random seed to something non-zero (I use 1 but the value
  should not matter) in the .MO file.
\item It often helps to select the option to use standard starting values in the
  .MO file. This is necessary for the automatic parallel tests.
\item In R, use the argument \textsf{parallelTesting=TRUE} in the call to
  \textsf{siena07}.
\item Use the module \textsf{simstats0c} as the function when creating the
  model.
\end{enumerate}
\paragraph{Automatic tests}
\begin{enumerate}
\item
Select the correct versions of the random number generator as above.
\item Build  siena03, siena01, siena07
\item The automatic system needs some test files in the siena3324xx directory:
\begin{description}
\item[VRND32T3.DAT]
\item[VRND32T4.DAT]
\item[time23.dat]
\item[tmp34.in]
\item[effectsTest.bat]
\end{description}
There are more than one version of these data files around. The first two should
be the same as the objects tmp3 and tmp4 in RSiena. Use the same time23.dat file
in each case.
\item Create a directory in the siena3 directory called effectsTest.
\item  run \verb|siena01 tmp34|
\item Set the random seed to something non-zero (I use 1 but the value
  should not matter) in the .MO file.
\item Select the option to use standard starting values in the
  .MO file.
\item Set the number of subphases in phase2 to 2, and the number of iterations
  in phase3 to 100.
\item At the command prompt type\\
\verb|sh < effectsTest.bat|
\item and wait... (not so long now!)
\item when finished you should have 4 txt files to diff with the R ones:
  comp.txt, compc.txt, compfd.txt, compfdc.txt. They will not be exactly the
  same...
\item The R part is run by the command (somewhere else with a subdirectory
  called effectsTest, containing time23.dat):
 \verb|R --vanilla < effectsTest.R|
\item The R .txt files are in the effectsTest subdirectory, the siena3324 ones
  are in the main directory.
\item The subdirectories contain the .cck files and the equivalent from R, in
  files called things like eval\%.tmp, endow\%.tmp.
\item The .out files are stored in 4 parts: sienanonc.out, sienac.out,
  sienafdnonc.out, sienafd.out.
\item The detailed files can be used to find out more about runs that did not
  match.
\end{enumerate}
\section{Profiling}
If you are interested in knowing where RSiena spends its time, you can examine
the R part by:
\begin{verbatim}
Rprof()
siena07(...)
Rprof(NULL)
summaryRprof()
\end{verbatim}
For the C part it is a lot harder. An outline of the use of \verb|gprof|:
\begin{enumerate}
\item Our set-up works for networks, behavior variables and the various
  covariates. 1 group only.
\item You will need a standalone RMath library. You can find out how to create
  this in the R-admin manual.
\item Run siena07 with the extra argument \textsf{profileData=TRUE}.
\item This creates a file called \textsf{data.txt}. Move this to the directory
  \textsf{src}.
\item In R, run the code, assuming the effects object is called \textsf{myeff}
  and you have nothing valuable called \textsf{tmp}:
\begin{verbatim}
tmp <- myeff[myeff$include,c(1,4,7,13,14,5,6,17,21,23,16)]
tmp[tmp==""] <- NA
write.table(tmp, 'effects.txt', quote=FALSE, row.names=FALSE,
col.names=FALSE, na="NA")
\end{verbatim}
\item This creates a file called \textsf{effects.txt}.  Move this to the
  directory \textsf{src}.
\item In the \textsf{src} directory,
\begin{verbatim}
make -f makefile.profile clean
make -f makefile.profile
SienaProfile.exe
gprof SienaProfile.exe gmon.out > gprof.out
more gprof.out
\end{verbatim}
\item You will need to adjust the \textsf{RHOME} line in
  \textsf{makefile.profile} to reflect the location of R on your system.
\item Google for ``gprof'' to find out how to understand the output!
\end{enumerate}

There are alternatives on linux (\textsf{oprofile}) or Mac OS (\textsf{shark}).
A few notes about each:
\begin{description}
\item[oprofile]
\begin{enumerate}
\item You need root privileges to start or stop the daemon, and to reset it.
\item It is a resource hog.
\item The callgraph option only used to work on 32 bit machines.
\item Failed to work on Fedora 10 as installed in the statistics department, but
  possibly this has been updated.
\item \verb|opcontrol --start| to start it
\item \verb|opcontrol --callgraph=n| to get a callgraph.
\item \verb|opcontrol --reset| to start the collection again
\item Then run the R command
\item \verb|opcontrol --dump| create a file you can get reports from
\item \verb|opreport -l siena.so| to get a report. (Maybe Rsiena.so now)
\item \verb|opannotate -d src srcdir| to get annotated output
\item \verb|opcontrol --shutdown| to stop daemon
\end{enumerate}
\item[shark]
\begin{enumerate}
\item Make sure shark is installed
\item Start it
\item Run your R command
\item During the run, click Start and then Stop  on the Shark window
\item If you have the right settings a callgraph will appear in Shark.
\item I found that saving the results usually failed to work.
\item This route is the only one I found which would include C functions like
  exp in the profiling, although it is possible you may find a profiled gcc
  math library available for a Linux installation.
\end{enumerate}
\end{description}

In any of these cases, you may find results vary due to garbage
collection in R.
\section{Debugging C++}
You may find that R tends to crash when you change the C++. You can try to trap
the error using \sfn{Rprintf} statements to print out details at intervals. The
syntax for \sfn{Rprintf} is the same as the C function \sfn{printf}, but output
from the R version appears in the R console where other output will not. You
need the header file \sfn{"R\_ext/Print.h"} which may already be
included in any file I have debugged! To print out R objects (arguments or
objects you have created in the C++), use
\sfn{PrintValue(SEXP xx)}: this requires the header file \sfn{Rinternals.h}.

If you have access to a Linux machine, you can use a program called
\sfn{valgrind} to find places where you access memory which you should not, and
similar things. The usage is described in the Writing R Extensions manual. I
use, at the command line,\\
\sfn{R -d "valgrind --tool=memcheck --leak-check=full " --vanilla < valgrind.r}
\\
where valgrind.r contains the commands I want to run, \emph{followed by
  \sfn{gc()}} to do some R garbage collection. (Otherwise \sfn{valgrind} reports
a lot of still reachable memory at the end.)

\sfn{valgrind} will also report memory leaks which may not cause an error, just
an embarrassingly large memory usage, which will fail sooner or later.

If \sfn{valgrind} reports use of uninitialised variables, use the option
\sfn{--track-origins=yes} to find out where the problem started. It can be
surprisingly difficult to track these down!
\section{The R C++ interface}
This is not easy to understand from the documentation, but there should be
examples of most functions in the code already. Some notes:
\begin{description}
\item[random numbers]
We use the R random number functions such as \sfn{rexp}. These work slightly
differently from the R versions, you need to check the syntax of the call in
the manual if adding new ones. The header required is \sfn{Rmath.h}.
\item[Random number seeds] The functions\sfn{GetRNGstate} and
\sfn{PutRNGstate}  are used to get the R random number seed into the C++
process and then replace it in the R. The header for these is
\sfn{R\_ext/Random.h}.
\item[rlecuyer]
With multiple processes we use the random numbers from the \sfn{rlecuyer}
package. The seed is set in eg \sfn{robmon} (in the R code). There is code in
\sfn{siena07.cpp} which shows how to set and reset these if you must. The
different streams are intended to be kept apart, so for finite differencing
where we need common random number streams I have advanced to a new substream at
the beginning of each real iteration and reset to this point at the beginning of
each finite difference one. The jump to the new substream ignores the current
state so it does not matter if the streams get muddled up during the finite
differencing stage.
\item[errors]
Error messages can use the function \sfn{error} which is similar to
\sfn{Rprintf} in syntax, and needs the header file \sfn{R\_ext/error.h}.
\end{description}
\section{C++ platform independence}
A few notes of problems we have had:
\begin{itemize}
\item With some compilers you need to add \sfn{<string>} if you use
  \sfn{<stdexcept>}. Often this will be included somewhere else in the path, but
  if you add \sfn{<stdexcept>} it would be good to add \sfn{<string>} also.
  \item If you work on a Mac, currently you will find it easier to remove the
    word \sfn{clean} from the make file \sfn{Makevars}. I suggest you do this in
    a personal copy in a directory \sfn{.R} in your home directory, though, so
    that when you build and check the package it will get the right one. Also
    use the INSTALL flag: \sfn{R CMD INSTALL --no-multiarch dirname} to retain
    unchanged object files between installs. Hopefully this will cease to be a
    problem at some stage.
\item Also remove the word \sfn{clean} from the makefile on Linux.
  \item Be careful with \sfn{abs}. The integer version is in \sfn{<cstdlib>} not
    \sfn{<cmath>}. Compilation may fail with message about ambiguity.
\end{itemize}
\section{Algorithms}
This section outlines the different options available to the (expert!) user.
\subsection{Within siena07}
\begin{itemize}
\item I have created a copy of \sfn{DoIterations}, called
  \sfn{DoIterationsCopy}. Moving a `\#' from one call to the other in
  \sfn{proc2subphase} will switch usage. Make your changes to the copy version,
  so you can reinstate the working version by reverting the comment placing.
\item Most of the possible changes are in \sfn{DoIterations}, but I have added
  the facility to use regression rather than a simple average at the end of the
  subphases. This is controlled by a parameter \sfn{useAerage} in
  \sfn{proc2Subphase}, set to \sfn{TRUE} by default. Change it by editing the
  file! You also need to use \sfn{doIterationsCopy} to force the retention of
  all the parameter values and deviations.
\item Within \sfn{doIterationsCopy}, the update step has been removed to a
  function, \sfn{doChangeStep}, and a loop to do importance sampling steps
  inserted. The step continue until the variance of the weights is greater than
  one tenth the value with all mass concentrated at one point., or to 25
  (hard-coded!). A parameter \sfn{numberIterations} controls the number of
  samples used. Default to 10, change it by editing!
\item Flags are available in \sfn{doIterationsCopy} to store the chains and
  change contributions in C. Predicted statistics or scores are obtained from
  the function \sfn{predictOutcomes}, which uses the robust method of
  recalculation of likelihood in C.
\item If you have sourced the file \sfn{algorithms.r}, then other options for
  this calculation could be tried using the functions in that file.
\item There is also a preexisting system for maximum likelihood which just
  recalculates the scores and does another iteration. Based on
  \sfn{doMoreUpdates}.
\item \sfn{doIterationsCopy} will not function with conditional estimation,
and will not do anything sensible with missing data (yet!). So avoid missing
data.
\item You need to set \sfn{returnDeps=TRUE} on the call to \sfn{siena07}.
\item You might want to alter the number of iterations per subphase. This is set
  in the function \sfn{AnnouncePhase} (code in \sfn{siena07.r}).
\item More than two waves, or multigroups, would be very experimental!
\end{itemize}
\subsection{Standalone}
Use the file \sfn{algorithms.r}. This is in the \sfn{inst/examples} directory in
the source to keep it out of the way of build procedures. (In the examples
directory in the installed package.) Source it to use it. There is no need to
rebuild the package after changing this file. (If it needs functions from the
package it accesses them using \sfn{RSiena:::}. 

The basic outline is described here. The parameters are passed to the initialize
routine and then stored on \sfn{z}. I think their use will be fairly clear if
you read what follows (and the code!) 

No promises about robustness, and the routine is designed to be hacked rather
than run unchanged. But examples of use are in file \sfn{runalg.r}.

Bayesian routine is not documented here, as it is part of the package and has
a help page.

The graphs are semi-automatic, driven by a dataframe with a column for each
panel. Consult the code to see how it works: construct a formula from the column
names. It is a nice trick. There is no parameter to turn them off: comments them
out.  

None of this has been tested with more than two waves or with multiple groups. 
I suspect none of it would work!

\sfn{}

\begin{algorithmic}
\STATE Call AlgorithmsInitialize \ref{sec:init}
\REPEAT
\STATE
\REPEAT
\IF{using optim}
\IF{not finalLoop}
\STATE set number of samples for this iteration from optim schedule
\ENDIF
\STATE set the importance sampling weights to 1
\ENDIF
\STATE get the next set of samples: \ref{sec:samples}
\REPEAT
\IF{using optim}
\STATE store the old theta
\STATE do an optim update step: \ref{sec:optim}
\STATE get importance sampling weights at new theta
\IF {variance of weights high or more than maxiiter repeats or no change in
theta}
\STATE break
\ENDIF
\ELSIF {response surface}
\STATE do a reponse surface change step \ref{sec:resp}
\STATE break
\ELSE
\STATE do an algorithm change step: \ref{sec:algchange}
\IF{final loop and theta has not changed much}
\STATE break
\ENDIF
\STATE get predicted values (\ref{sec:pred}) and importance sampling weights at
new theta 
\IF{variance of importance sampling weights is large or more than
  \sfn{maxiiter} repeats} 
\STATE break
\ENDIF
\ENDIF
\UNTIL{for ever}
\STATE update the plots
\IF {using C storage}
\STATE clear the stores
\ENDIF
\IF {using history for optim}
\STATE store the samples
\ENDIF
\UNTIL{completed \sfn{numiter} iterations or more than \sfn{maxiiter} importance
sampling steps and still low variance or final loop}
\IF {not finalLoop}
\STATE set finalLoop to TRUE
\STATE set up things for final iteration: \ref{sec:final}
\ELSE
\STATE break
\ENDIF
\UNTIL{for ever}
\STATE Do termination call to C
\STATE Close any open processes
\end{algorithmic}
\subsubsection{Initialize}
\label{sec:init}
\begin{algorithmic}
\STATE call initializeFRAN to set data up in C
\STATE Store all the options on \sfn{z}
\STATE create useful variables (Some of this is done automatically now in
  \sfn{initialiseFRAN} but I have not pruned thus function.)
\STATE set finalLoop to FALSE
\end{algorithmic}
\subsubsection{Get next set of samples}
\label{sec:samples}
\begin{algorithmic}
\STATE get the samples
\STATE calculate derivative matrix
\STATE calculate likelihoods
\end{algorithmic}
\subsubsection{Optim change step}
\label{sec:optim}
\begin{algorithmic}
\STATE 2 functions provided: mean log likelihood (EM) or log mean
probability ratios (GT) 
\STATE Derivative calculation routines to match (hope these are correct!)
\STATE Default method is BFGS 
\STATE Default is just 1 iteration until final loop
\STATE Rates need logging unless you use L-BFGS-B. The functions take exp() at
the start.
\STATE Step length is limited to distance of the scale.
\STATE With EM you can reuse the historical samples downweighted by factor of
optimWeight each time. 
\STATE EM uses importance sampling weights 
\end{algorithmic}
\subsubsection{Response surface step}
\label{sec:resp}
\begin{algorithmic}
\STATE Use importance sampling to estimate the statistics at points around the
current parameter. 
\STATE Create a data frame with these and (down-weighted) previous results.
\STATE Fit a linear regression and solve for targets 0
\STATE Move is restricted to distance the scale factor.
\STATE There is a routine to fit a quadratic instead, and minimise the distance
from targets 0, but it does not work well. Usually not positive definite. Maybe
I coded it wrong. It uses raw orthogonal polynomials.
\end{algorithmic}
\subsubsection{Non optim change step}
\label{sec:algchange}
\begin{algorithmic}
\STATE Uses the phase 2 update step from siena07, with diagonal or full
derivative matrix as requested.
\end{algorithmic}
\subsubsection{Predictions}
\label{sec:pred}
\begin{algorithmic}
\STATE Get the log likelihoods
\STATE Subtract the values for the smaple
\STATE Exponentiate
\STATE Normalise to sum to 1
\IF {variance greater than maxVar}
\STATE make predictions NA
\ELSE
\STATE multiply by statistics or scores
\ENDIF 
\end{algorithmic}
\subsubsection{Calculating likelihoods and probabilities}
Various functions provided: the differences are the use of C or not and stored
change contributions or not, and which format is most convenient for the final
calculations.
\begin{description}
\item[useC] Uses getProbabilitiesFromCSTore to get hold of the log choices for
  each ministep using change contributions stored in C, and then uses
  getLikelihood3 to do the calculations. Memory intensive but fast. May not be
  robust. Rate values are not stored and rate part of calculation is done in
  R. Only currently works for forward simulation, where it is least useful! 
\item[NOT useC AND useSLowC] Uses getProbabilities to pass chain back into C and
  recalculate the chnage contributions to update the ministeps. Fairly quick,
  low memory demand, robust as reuses code that must be maintained. Recommended.
\item[NOT useC and NOT useSlowC] Uses getProbabilitiesR to calculate the choice
  probs using change contributions matrices stored in R. Not recommended unless
  you prefer changing R to C. Slow, memory intensive, and clumsy. Then uses 
getLikelihood2 to combine the values.  Only currently works for forward
simulation.
\end{description}
\subsubsection{Set up final iteration}
\label{sec:final}
\begin{algorithmic}
\STATE set \sfn{diag} flag off so use whole derivative matrix
\STATE reduce the gain to stop erratic behavior
\STATE set number of samples to finalIter
\STATE restart iteration count
\IF {using optim}
\STATE set maxit to 100
\STATE set maxiiter to 0
\STATE set optimFn to optimFinal
\STATE set useOptim to useOptimFinal: could do Newton-Raphson type updates
instead. 
\ELSE 
\STATE set maxiiter to 20
\ENDIF
\end{algorithmic}
\end{document}
